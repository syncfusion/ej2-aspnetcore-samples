@page
@model EJ2CoreSampleBrowser.Pages.Diagram.FamilyTreeModel
@using Syncfusion.EJ2
@using Syncfusion.EJ2.Diagrams

@section ControlsSection {
  <div class="control-section family-tree">
    <style>
      /* Diagram surface */
      .family-tree {
        background: #FFFFFF;
      }

      .family-tree .e-diagram {
        background: transparent;
      }

      .family-tree #diagramcontent {
        overflow: hidden !important;
      }

      /* ===================== Node base ===================== */
      .family-tree .person-node-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: #FFDBD1;
        border-radius: 10px;
        box-shadow: 0 2px 3px 0 rgba(0, 0, 0, .16);
        box-sizing: border-box;
        position: relative;
        transition: opacity 0.5s ease;
        will-change: transform;
        user-select: none;
      }

      .family-tree .person-node-container:hover {
        cursor: default !important;
        background: #f5e1a7;
      }

      /* Dim state driven by template */
      .family-tree .person-node-container.is-dim {
        opacity: 0.25;
        filter: grayscale(50%);
        transition: opacity 0.2s ease-out, filter 0.3s ease;
      }

      /* ===================== Open state driven by template ===================== */
      .family-tree .person-node-container.is-open .person-image-circle {
        position: absolute;
        top: 10px;
        left: 10px;
        margin: 0;
        width: 80px;
        height: 80px;
      }

      .family-tree .person-node-container.is-open .person-header {
        text-align: left;
        margin-left: 90px;
      }

      .family-tree .person-node-container.is-open .person-bio {
        max-height: 200px;
        opacity: 1;
      }

      .family-tree .person-node-container.is-open .person-full-name {
        display: block;
        font-size: 20px;
        text-align: left;
      }

      .family-tree .person-node-container.is-open .person-first-name {
        display: none;
      }

      .family-tree .person-node-container.is-open .person-tenure {
        font-size: 16px;
        text-align: left;
      }

      /* ===================== Card layout ===================== */
      .family-tree .person-card {
        display: grid;
        grid-template-rows: auto auto 1fr;
        gap: 8.5px;
        padding: 12px 8px 3px;
        border-radius: 10px;
        border: 2px solid #85736E;
        height: 100%;
        width: 100%;
        position: relative;
      }

      /* ===================== Avatar ===================== */
      .family-tree .person-image-circle {
        width: 98px;
        height: 98px;
        border-radius: 50%;
        margin: 0 auto;
        background: #f0f0f0;
        border: 3px solid #FFFFFF;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .family-tree .person-image {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      /* ===================== Header/Text ===================== */
      .family-tree .person-header {
        text-align: center;
        line-height: 1.2;
        position: relative;
        z-index: 1;
      }

      .family-tree .person-first-name,
      .family-tree .person-full-name {
        font-weight: 600;
        font-size: 21px;
        line-height: 1.2;
        text-align: center;
        color: #723523;
      }

      /* By default show first name only; full name appears when is-open */
      .family-tree .person-full-name {
        display: none;
      }

      .family-tree .person-tenure {
        font-size: 15px;
        color: #53433F;
        opacity: 0.85;
        margin-top: 4px;
        text-align: center;
      }

      /* ===================== Bio ===================== */
      .family-tree .person-bio {
        color: #723523;
        font-size: 18px;
        line-height: 1.35;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        margin-left: 90px;
        transition: opacity 0.2s ease;
      }

      /* ===================== Diagram visuals ===================== */

      /* Node width transition (diagram updates width on hover) */
      .family-tree [id$='_html_element'] {
        transition: all 80ms ease;
      }

      /* Connector animation */
      .family-tree [id$='_path'] {
        transition: opacity 0.4s ease, stroke 0.4s ease, stroke-width 0.4s ease;
      }
    </style>

    <div class="content-wrapper" style="width: 100%;">
      <ejs-diagram id="diagram" width="100%" height="600px" tool="ZoomPan">
        <e-diagram-snapsettings constraints="None"></e-diagram-snapsettings>
      </ejs-diagram>
    </div>

    <!-- Html Node Template -->
    <script type="text/x-template" id="nodetemplate">
      <div class="person-node-container">
        <div class="person-card">
          <!-- Avatar -->
          <div class="person-image-circle">
            ${if(data.ImageUrl)}
              <img src="${data.ImageUrl}" class="person-image" alt="${data.Name}" />
            ${/if}
          </div>

          <!-- Header: name + tenure -->
          <div class="person-header">
            <div class="person-full-name">${data.Name}</div>
            <div class="person-first-name">${data.FirstName}</div>
            <div class="person-tenure">${data.Tenure}</div>
          </div>

          <!-- Collapsible bio -->
          <div class="person-bio">${data.Description}</div>
        </div>
      </div>
    </script>

    <script>
      // Ported client logic from family-tree.ts to configure the ASP.NET Core Diagram instance
      (function () {
        var NODE_WIDTH = 140;
        var NODE_HEIGHT = 180;
        var HOVER_WIDTH = 320;
        var ORIGINAL_SIZE = new Map();
        var CONNECTOR_COLORS = { baseConnector: '#85736E', highlightedConnector: '#723523' };

        // Data will be loaded from external JSON ../scripts/diagram-data.json
        // We will fetch it first to build relations for hover/highlight logic,
        // then bind to the diagram using a JsonAdaptor-based DataManager.
        var REL = null; // will be assigned after data load

        function buildRelations(data) {
          var unions = data.filter(function (d) { return d.Type === 'Union'; });
          var spouseOf = new Map();
          var unionOf = new Map();
          var parentsByChild = new Map();
          var childrenByParent = new Map();

          unions.forEach(function (u) {
            var a = (u.Parents || [])[0];
            var b = (u.Parents || [])[1];
            if (!a || !b) return;
            unionOf.set(u.Id, [a, b]);
            spouseOf.set(a, b);
            spouseOf.set(b, a);
          });

          data.forEach(function (n) {
            if (Array.isArray(n.Parents)) {
              parentsByChild.set(n.Id, n.Parents.slice());
              n.Parents.forEach(function (ref) {
                var pr = unionOf.get(ref);
                if (!pr) return;
                var pa = pr[0], pb = pr[1];
                if (!childrenByParent.has(pa)) childrenByParent.set(pa, new Set());
                if (!childrenByParent.has(pb)) childrenByParent.set(pb, new Set());
                childrenByParent.get(pa).add(n.Id);
                childrenByParent.get(pb).add(n.Id);
              });
            }
          });

          return { spouseOf: spouseOf, unionOf: unionOf, parentsByChild: parentsByChild, childrenByParent: childrenByParent };
        }

        // REL will be set after external JSON is loaded
        var familyTreeData = [];

        function hostOf(id) { return document.getElementById(id + '_html_element'); }
        function containerOf(id) {
          var host = hostOf(id);
          return host ? host.querySelector('.person-node-container') : null;
        }
        function setTemplateOpen(id, open) {
          var cont = containerOf(id); if (!cont) return; cont.classList.toggle('is-open', open);
        }
        function setNodeDim(id, dim) {
          var cont = containerOf(id); if (!cont) return; cont.classList.toggle('is-dim', dim);
        }
        function paintConnectors(diagram, nodeSet) {
          diagram.connectors.forEach(function (c) {
            var s = c.sourceID, t = c.targetID;
            var has = s && t && nodeSet.has(s) && nodeSet.has(t);
            c.style = { strokeColor: has ? CONNECTOR_COLORS.highlightedConnector : CONNECTOR_COLORS.baseConnector, opacity: has ? 1 : 0.2 };
          });
        }
        function relatedSet(personId) {
          var people = new Set([personId]);
          var spouse = REL.spouseOf.get(personId); if (spouse) people.add(spouse);
          var parentUnions = new Set(REL.parentsByChild.get(personId) || []);
          parentUnions.forEach(function (u) { (REL.unionOf.get(u) || []).forEach(function (p) { return people.add(p); }); });
          var kids = REL.childrenByParent.get(personId);
          if (kids) kids.forEach(function (k) { return people.add(k); });
          var unions = new Set(parentUnions);
          var spouseOrSelf = new Set([personId].concat(spouse ? [spouse] : []));
          (kids || new Set()).forEach(function (childId) {
            var parents = REL.parentsByChild.get(childId) || [];
            parents.forEach(function (u) {
              var pair = REL.unionOf.get(u);
              if (pair && (spouseOrSelf.has(pair[0]) || spouseOrSelf.has(pair[1]))) unions.add(u);
            });
          });
          var nodeSet = new Set(people); unions.forEach(function (u) { return nodeSet.add(u); });
          return { people: people, nodeSet: nodeSet };
        }

        function expandForHover(diagram, id) {
          var node = diagram.getObject(id);
          if (!node || (node.data && node.data.Type === 'Union')) return;
          if (!ORIGINAL_SIZE.has(id)) ORIGINAL_SIZE.set(id, { width: node.width, height: node.height });
          node.width = HOVER_WIDTH; setTemplateOpen(id, true);
        }
        function shrinkFromHover(diagram, id) {
          var node = diagram.getObject(id); if (!node) return;
          var orig = ORIGINAL_SIZE.get(id);
          if (orig) { node.width = orig.width; node.height = orig.height; }
          setTemplateOpen(id, false);
        }

        var hoveredId = null;
        function focusHover(diagram, id) {
          if (hoveredId && hoveredId !== id) shrinkFromHover(diagram, hoveredId);
          var sets = relatedSet(id), people = sets.people, nodeSet = sets.nodeSet;
          diagram.nodes.forEach(function (n) {
            var nid = n.id; var isPerson = !(n.data && n.data.Type === 'Union');
            setNodeDim(nid, isPerson && nid !== id && !people.has(nid));
          });
          expandForHover(diagram, id); paintConnectors(diagram, nodeSet); hoveredId = id;
        }
        function clearHover(diagram) {
          if (hoveredId) { shrinkFromHover(diagram, hoveredId); hoveredId = null; }
          diagram.nodes.forEach(function (n) { return setNodeDim(n.id, false); });
          diagram.connectors.forEach(function (c) { c.style = { strokeColor: CONNECTOR_COLORS.baseConnector, strokeWidth: 2, opacity: 1 }; });
        }

        function created() { var d = document.getElementById('diagram').ej2_instances[0]; d.fitToPage(); }

        // After the wrapper renders, configure advanced settings mirroring TS sample
        document.addEventListener('DOMContentLoaded', function () {
          var diagram = document.getElementById('diagram').ej2_instances[0];

          diagram.layout = {
            type: 'ComplexHierarchicalTree',
            orientation: 'TopToBottom',
            horizontalAlignment: 'Center',
            verticalAlignment: 'Top',
            horizontalSpacing: 150,
            verticalSpacing: 50
          };

          diagram.getConnectorDefaults = function (connector) {
            connector.type = 'Orthogonal';
            connector.style = { strokeColor: CONNECTOR_COLORS.baseConnector, strokeWidth: 2 };
            connector.targetDecorator = { shape: 'None' };
            connector.cornerRadius = 5; return connector;
          };

          diagram.nodeTemplate = '#nodetemplate';

          diagram.mouseEnter = function (args) {
            var node = args && args.actualObject;
            if (!node || node.data && node.data.Type === 'Union' || node instanceof ej.diagrams.Connector) return;
            focusHover(diagram, node.id);
          };
          diagram.mouseLeave = function () { clearHover(diagram); };
          diagram.dataLoaded = function () { setTimeout(function () { return diagram.fitToPage(); }); };

          // Load JSON, then bind
          fetch('../scripts/diagram-data.json', { cache: 'no-store' })
            .then(function (r) { return r.json(); })
            .then(function (json) {
              var data = json.familyTreeData || json;
              familyTreeData = data;
              REL = buildRelations(familyTreeData);

              diagram.dataSourceSettings = {
                id: 'Id',
                parentId: 'Parents',
                dataSource: new ej.data.DataManager(familyTreeData),
                doBinding: function (node, raw) {
                  node.id = String(raw.Id); node.data = raw;
                  if (raw.Type === 'Union') {
                    node.width = 0; node.height = 0; node.shape = { type: 'Basic', shape: 'Rectangle' };
                    node.style = { fill: 'transparent', strokeColor: 'transparent' }; node.visible = false;
                  } else {
                    raw.ImageUrl = raw.ImageUrl || ('../images/Diagram/family-tree/' + raw.Name + '.png');
                    node.shape = { type: 'HTML' }; node.width = NODE_WIDTH; node.height = NODE_HEIGHT;
                  }
                }
              };

              diagram.dataBind();
              diagram.refresh();
              created();
            })
            .catch(function (e) { console.error('Failed to load family tree data:', e); });
        });
      })();
    </script>
  </div>
}

@section ActionDescription{
  <p>
    This sample showcases a family tree built with the Syncfusion<sup>®</sup> ASP.NET Core Diagram,
    illustrating complex hierarchical relationships through customizable node templates, interactive hover details, and
    relation-based highlighting.
  </p>
}

@section Description{
  <p>
    The diagram uses a complex hierarchical tree layout to automatically arrange family members in a clear,
    top-to-bottom structure. Each node is rendered using a custom HTML template that displays the individual’s photo,
    name, and lifespan. On hover, the node expands to reveal relationship details, while related members are highlighted
    and all other nodes are dimmed to enhance focus.
  </p>
}

@section Title{
  <title>ASP.NET Core Diagram Family Tree Example - Syncfusion Demos</title>
}

@section Header{
  <h1 class='sb-sample-text'>Example of Family Tree in ASP.NET Core Diagram Component</h1>
}