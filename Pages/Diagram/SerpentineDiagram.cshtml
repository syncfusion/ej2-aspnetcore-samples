@page
@model EJ2CoreSampleBrowser.Pages.Diagram.SerpentineDiagramModel
@using Syncfusion.EJ2

@section ControlsSection{
    <div class="control-section serpentine-diagram-container">
        <div class="sample-section">
            <div class="content-wrapper">
                <div class="diagram-header">
                    <h3 class="text-center mb-3">Medical Research Breakthroughs</h3>
                    <p class="text-muted text-center mb-4">
                        A serpentine journey through 20 pivotal medical discoveries that changed healthcare forever
                    </p>
                </div>
                <div class="zoom-controls-container" style="padding: 0 0 15px 0; text-align: center;">
                    <ejs-button id="zoom-065" content="0.65x" isPrimary="true"></ejs-button>
                    <ejs-button id="zoom-075" content="0.75x"></ejs-button>
                    <ejs-button id="zoom-085" content="0.85x"></ejs-button>
                    <ejs-button id="zoom-1" content="1x"></ejs-button>
                </div>
                <div>
                    <ejs-diagram id="serpentineDiagram"
                                 width="100%"
                                 height="600px"
                                 cssClass="diagram-container"
                                 snapSettings="@Model.SnapSettings"
                                 created="onDiagramCreated">
                        <e-diagram-nodes></e-diagram-nodes>
                        <e-diagram-connectors></e-diagram-connectors>
                    </ejs-diagram>
                </div>
            </div>
        </div>
    </div>

    <script>
        function onDiagramCreated() {
            const diagram = document.getElementById('serpentineDiagram').ej2_instances[0];
            const diagramNs = ej.diagrams;

            diagram.tool = diagramNs.DiagramTools.ZoomPan;
            diagram.scrollSettings = {
                scrollableArea: new diagramNs.Rect(0, 0, 1500, 1500),
                padding: { right: 50, bottom: 50 }
            };

            const medicalBreakthroughs = @Html.Raw(Json.Serialize(Model.MedicalBreakthroughs));

            const PALETTE = ['#2E86C1', '#2A6F1C', '#C25107', '#8E44AD', '#C0392B', '#40566d', '#8E7302'];

            const NODE_SIZE = 110;
            const H_GAP = 60;
            const V_GAP = 150;

            const BASE_MARGIN = 50;
            const CURVE_RADIUS = H_GAP * 1.5;
            const CURVE_BOW = 70;
            const CURVE_PADDING = CURVE_RADIUS + 2 * CURVE_BOW;
            const TOTAL_MARGIN = BASE_MARGIN + CURVE_PADDING;

            const INITIAL_Y = 80;

            const CONNECTOR_STROKE_WIDTH = 12;
            const DECORATOR_WIDTH = 20;
            const DECORATOR_HEIGHT = 30;
            const DECORATOR_PIVOT_INNER = 0.25;
            const DECORATOR_PIVOT_OUTER = 0.25;
            const DECORATOR_PATH = 'M 16 16 c -8 1 -7 1 -11 3 C 7 16 7 13 5 10 c 4 2 3 2 11 3 z';

            const zoomButtons = {};
            const zoomFactors = {
                'zoom-065': 0.65,
                'zoom-075': 0.75,
                'zoom-085': 0.85,
                'zoom-1': 1
            };

            Object.keys(zoomFactors).forEach(function (id) {
                const buttonElement = document.getElementById(id);
                if (!buttonElement) { return; }

                const buttonInstance = buttonElement.ej2_instances && buttonElement.ej2_instances[0];
                if (buttonInstance) {
                    zoomButtons[id] = buttonInstance;
                }

                buttonElement.addEventListener('click', function () {
                    const currentZoom = diagram.scrollSettings.currentZoom || 0.65;
                    const targetZoom = zoomFactors[id];
                    const zoomFactor = targetZoom / currentZoom;

                    const focusPoint = {
                        x: diagram.scrollSettings.viewPortWidth / 2,
                        y: diagram.scrollSettings.viewPortHeight / 2
                    };

                    diagram.zoom(zoomFactor, focusPoint);

                    renderSerpentineLayout();

                    diagram.scrollSettings.horizontalOffset = 0;
                    diagram.scrollSettings.verticalOffset = 0;
                    diagram.dataBind();

                    Object.keys(zoomButtons).forEach(function (key) {
                        zoomButtons[key].isPrimary = key === id;
                    });
                });
            });

            function createDecorator(color, pivotX) {
                return {
                    shape: 'Custom',
                    width: DECORATOR_WIDTH,
                    height: DECORATOR_HEIGHT,
                    pivot: { x: pivotX },
                    pathData: DECORATOR_PATH,
                    style: { fill: color, strokeColor: color }
                };
            }

            function renderSerpentineLayout() {
                const hostElement = diagram.element;
                if (!hostElement) { return; }

                const zoom = diagram.scrollSettings.currentZoom || 1;
                const effectiveWidth = hostElement.clientWidth / zoom;

                const nodes = [];
                const connectors = [];

                let currentX = TOTAL_MARGIN + NODE_SIZE / 2;
                let currentY = INITIAL_Y;
                let direction = 1; // 1 = left-to-right, -1 = right-to-left

                medicalBreakthroughs.forEach(function (breakthrough, index) {
                    const exceedsRight = direction === 1 && currentX + NODE_SIZE / 2 > effectiveWidth - TOTAL_MARGIN;
                    const exceedsLeft = direction === -1 && currentX - NODE_SIZE / 2 < TOTAL_MARGIN;

                    if (exceedsRight || exceedsLeft) {
                        currentY += V_GAP;
                        direction = direction === 1 ? -1 : 1;
                        currentX = direction === 1
                            ? TOTAL_MARGIN + NODE_SIZE / 2
                            : effectiveWidth - TOTAL_MARGIN - NODE_SIZE / 2;
                    }

                    const color = PALETTE[index % PALETTE.length];

                    const node = {
                        id: 'breakthrough_' + breakthrough.Id,
                        offsetX: currentX,
                        offsetY: currentY,
                        width: NODE_SIZE,
                        height: NODE_SIZE,
                        shape: { type: 'Basic', shape: 'Ellipse' },
                        style: { fill: color, strokeColor: 'white', strokeWidth: 4 },
                        annotations: [
                            {
                                content: breakthrough.Year,
                                offset: { y: 0.3 },
                                style: { color: 'white', fontSize: 16, bold: true }
                            },
                            {
                                content: breakthrough.Title,
                                width: 80,
                                offset: { y: 0.65 },
                                style: {
                                    color: 'white',
                                    fontSize: 12,
                                    textOverflow: 'Wrap',
                                    textWrapping: 'WrapWithOverflow'
                                }
                            }
                        ],
                        ports: [
                            {
                                id: 'port_left',
                                offset: { x: 0, y: 0.5 },
                                visibility: diagramNs.PortVisibility.Hidden
                            },
                            {
                                id: 'port_right',
                                offset: { x: 1, y: 0.5 },
                                visibility: diagramNs.PortVisibility.Hidden
                            }
                        ],
                        constraints: ((diagramNs.NodeConstraints.Default | diagramNs.NodeConstraints.Tooltip) & ~diagramNs.NodeConstraints.Select),
                        tooltip: {
                            content: "<p style='font-size: small;'><b>" + breakthrough.Title + " (" + breakthrough.Year + ")</b><br/><br/>" + breakthrough.Description + '</p>',
                            position: 'BottomCenter',
                            relativeMode: 'Object',
                            width: 200
                        }
                    };

                    nodes.push(node);
                    currentX += direction * (NODE_SIZE + H_GAP);
                });

                for (let i = 0; i < nodes.length - 1; i++) {
                    const sourceNode = nodes[i];
                    const targetNode = nodes[i + 1];
                    const rowChanged = sourceNode.offsetY !== targetNode.offsetY;

                    let sourcePortId;
                    let targetPortId;

                    if (rowChanged) {
                        const nextRowStartsOnRight = sourceNode.offsetX < targetNode.offsetX;
                        sourcePortId = nextRowStartsOnRight ? 'port_right' : 'port_left';
                        targetPortId = sourcePortId;
                    } else {
                        const leftToRight = sourceNode.offsetX < targetNode.offsetX;
                        sourcePortId = leftToRight ? 'port_right' : 'port_left';
                        targetPortId = leftToRight ? 'port_left' : 'port_right';
                    }

                    const color = sourceNode.style.fill;

                    const connector = {
                        id: 'connector_' + (i + 1),
                        sourceID: sourceNode.id,
                        targetID: targetNode.id,
                        sourcePortID: sourcePortId,
                        targetPortID: targetPortId,
                        style: { strokeColor: color, strokeWidth: CONNECTOR_STROKE_WIDTH },
                        targetDecorator: createDecorator(color, rowChanged ? 0 : DECORATOR_PIVOT_INNER),
                        sourceDecorator: createDecorator(color, DECORATOR_PIVOT_OUTER),
                        constraints: diagramNs.ConnectorConstraints.Default & ~diagramNs.ConnectorConstraints.Select
                    };

                    if (rowChanged) {
                        const goingRight = sourceNode.offsetX < targetNode.offsetX;
                        const sign = goingRight ? 1.3 : -1.3;
                        const controlX = sourceNode.offsetX + sign * (NODE_SIZE / 2 + CURVE_RADIUS + 2 * CURVE_BOW);

                        connector.type = 'Bezier';
                        connector.segments = [{
                            type: 'Bezier',
                            point1: { x: controlX, y: sourceNode.offsetY + 5 },
                            point2: { x: controlX, y: targetNode.offsetY - 15 }
                        }];
                    } else {
                        connector.type = 'Straight';
                    }

                    connectors.push(connector);
                }

                diagram.nodes = nodes;
                diagram.connectors = connectors;
                diagram.dataBind();
            }

            let resizeRaf = 0;
            window.addEventListener('resize', function () {
                if (resizeRaf) {
                    cancelAnimationFrame(resizeRaf);
                }
                resizeRaf = requestAnimationFrame(function () {
                    renderSerpentineLayout();
                });
            });

            const INITIAL_ZOOM = 0.65;
            requestAnimationFrame(function () {
                const currentZoom = diagram.scrollSettings.currentZoom || INITIAL_ZOOM;
                const focusPoint = {
                    x: diagram.scrollSettings.viewPortWidth / 2,
                    y: diagram.scrollSettings.viewPortHeight / 2
                };

                if (Math.abs(currentZoom - INITIAL_ZOOM) > 0.001) {
                    diagram.zoom(INITIAL_ZOOM / currentZoom, focusPoint);
                }

                diagram.scrollSettings.horizontalOffset = 0;
                diagram.scrollSettings.verticalOffset = 0;
                renderSerpentineLayout();
            });
        }
    </script>
}

@section Meta{
    <meta name="description" content="Visualizes a custom serpentine layout with the Diagram component, featuring 20 key medical breakthroughs that revolutionized healthcare (1796–1996)."/>
}

@section ActionDescription{
    <p>
        This sample visualizes a serpentine layout using the Syncfusion<sup>®</sup> ASP.NET Core Diagram to showcase 20 important medical research breakthroughs that transformed healthcare between 1796 and 1996.
    </p>
}

@section Description{
    <p>
        A serpentine layout arranges elements along a zigzagging or winding path. This timeline presents each breakthrough as part of a continuous sequence. When the layout reaches the edge of the view, it wraps to the next line and reverses direction, creating a true serpentine flow.    
    </p>
    <p>
        <strong>Key Features:</strong>
    </p>
    <ul>
        <li><strong>Dynamic Serpentine Flow:</strong> Nodes are automatically arranged in a winding path that wraps based on the available container width.</li>
        <li><strong>Interactive Nodes:</strong> Hover over any node to see a detailed tooltip with information about the medical breakthrough.</li>
        <li><strong>Custom Connectors:</strong> The timeline uses straight connectors for nodes in the same row and elegant bezier curves for wrapping between rows.</li>
        <li><strong>Zoom and Pan:</strong> Use the buttons to zoom in and out at specific zoom levels.</li>
    </ul>
    <br>
}

@section Title{
    <title>ASP.NET Core Diagram Serpentine Timeline Example - Syncfusion Demos</title>
}

@section Header{
    <h1 class='sb-sample-text'>Example of Serpentine Timeline in ASP.NET Core Diagram Control</h1>
}

<style>
    .serpentine-diagram-container {
        padding: 20px;
        background-color: #f8f9fa;
        min-height: 600px;
    }

    .diagram-header h3 {
        color: #495057;
        font-weight: 600;
        margin-top: 0;
    }

    .zoom-controls-container .e-btn {
        margin: 0 5px;
    }

    .diagram-container {
        border: 1px solid #dee2e6;
        border-radius: 8px;
        background-color: #ffffff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    @@media (max-width: 768px) {
        .serpentine-diagram-container {
            padding: 10px;
        }

        .diagram-container {
            min-height: 600px;
        }
    }
</style>